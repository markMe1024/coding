### 基于注解实现操作日志记录及异常统一处理

操作日志用来记录是谁、在什么时候、做了什么，通常对新增、修改、删除操作进行记录，而不对查询操作进行记录。记录操作日志主要需要以下信息：操作对象（网络、安全组、云主机...）、操作类型（新增、修改、删除）、操作日志级别（低、中、高）、资源Id，以及资源名称。其中操作对象、操作类型、操作日志级别信息通过注解储存，资源Id、资源名称通过使用父类BaseController的静态变量储存。

该方案实现了操作日志的记录，异常统一处理，打印入参出参。

涉及到的技术包括自定义注解、反射、Spring Aop。

#### 1. 自定义注解

自定义注解`OptLog`，作用于`Controller`层的方法上。用来声明操作对象、操作类型、操作日志级别，以及是否只记录操作失败日志。自定义注解源码如下：

```java
package com.inspur.incloud.aop.annotation;

import com.inspur.incloud.log.EventLevel;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 操作日志注解，成功或者失败都记录，用于同步操作
 *
 * @author lidongyue
 * @since 2019-01-29
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD})
public @interface OptLog {
    /**
     * 操作对象
     */
    String optTarget();

    /**
     * 操作类型
     */
    String optType();

    /**
     * 操作日志级别
     */
    EventLevel optLevel();

    /**
     * 是否是一个同步方法，默认是异步false，异步只记录操作失败日志；true为同步，同步既记录操作失败日志，又记录操作成功日志
     */
    boolean isSyn() default false;

}
```

#### 2. 父类BaseController

资源Id、资源名是需要从代码内获取的，所以通过注解的方式赋值并不合适。东岳这里定义了BaseController，其他Controller通过继承它，可以直接使用它定义的静态变量idVal、nameListVal来储存资源Id和资源名。

获取UserSession及它储存的信息，原本是大部分Controller方法中要做的事。现在将这件事抽象出来，定义在BaseController中，其他Controller通过继承BaseController，便都拥有了这个方法，这使得其他Controller的代码变得更轻更简洁。

```java
package com.inspur.incloud.aop.controller;

import com.inspur.incloud.common.UserSession;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

import javax.servlet.http.HttpServletRequest;
import java.util.ArrayList;
import java.util.List;

/**
 * @description: controller父类，用于获取userSession等
 * @author: lidongyue
 * @since 2019-02-11
 **/
public class BaseController {

    /**
     * 存name，为操作日志做准备
     */
    protected static ThreadLocal<List<String>> nameListVal = ThreadLocal.withInitial(() -> new ArrayList<>());
    /**
     * 存id，为操作日志做准备
     */
    protected static ThreadLocal<String> idVal = new ThreadLocal<>();

    protected static  ThreadLocal<String> lockPathVal = new ThreadLocal<>();

    public static ThreadLocal<String> getIdVal() {
        return idVal;
    }

    public static ThreadLocal<List<String>> getNameListVal() {
        return nameListVal;
    }

    protected UserSession getUserSession() {
        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();
        return (UserSession) request.getAttribute("userSession");
    }
}
```

#### 3. Aop

通过前两步，记录操作日志需要的信息就已经齐整，接下来开始记录。这里采用Spring提供的Aop，首先定义扫描位置：Controller层加了`OptLog`注解的方法。从这里我们也可以看到，`OptLog`注解不仅能储存记录操作日志需要的信息，也能作为一个标识，区分加了这个注解的方法和其他方法。示例代码如下：

```java
package com.inspur.incloud.aop;

import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;


/**
 * @description: 记录错误日志，统一处理异常
 * @author: lidongyue
 * @since 2019-01-14
 **/
@Aspect
@Component
@Slf4j
public class AopController {

    @Around("execution(com.inspur.incloud.common.OperationResult com.inspur.incloud.icompute.*.controller..*.*(..)) && (@annotation(com.inspur.incloud.aop.annotation.OptLog))")
    public Object aroundOptControllerAdvice(ProceedingJoinPoint joinPoint) {
        
    }
}
```

然后，打印入参、执行时间、返回结果，示例代码如下：

``` java
package com.inspur.incloud.aop;

import com.alibaba.fastjson.JSONObject;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.reflect.MethodSignature;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.lang.reflect.Method;

/**
 * @description: 记录错误日志，统一处理异常
 * @author: lidongyue
 * @since 2019-01-14
 **/
@Aspect
@Component
@Slf4j
public class AopController {

    /**
     * controller切面，录操作日志
     *
     * @param joinPoint
     * @return
     */
    @Around("execution(com.inspur.incloud.common.OperationResult com.inspur.incloud.icompute.*.controller..*.*(..))" +
            " && (@annotation(com.inspur.incloud.aop.annotation.OptLog))")
    public Object aroundOptControllerAdvice(ProceedingJoinPoint joinPoint) {
        Object returnObject = null;
        try {
            // 1.打印入参
            Class<?> clazz = joinPoint.getTarget().getClass();
            String className = clazz.getName();

            Method method = ((MethodSignature) joinPoint.getSignature()).getMethod();
            String methodName = method.getName();

            String args = JSONObject.toJSONString(joinPoint.getArgs());

            Logger logger = LoggerFactory.getLogger(clazz);
            logger.info(className + "." + methodName + " invoke begin, param = " + args);

            // 2.打印执行时间和返回结果
            long startTime = System.currentTimeMillis();

            returnObject = joinPoint.proceed();
            
            Long executeTime = System.currentTimeMillis() - startTime;

            logger.info(className + "." + methodName + " invoke end. executeTime=" + executeTime + ", return result=" + JSONObject.toJSONString(returnObject));
        } catch (Throwable e) {
            e.printStackTrace();
        }
        return returnObject;
    }
}
```

再然后记录操作日志

```java
package com.inspur.incloud.aop;

import com.alibaba.fastjson.JSONObject;
import com.inspur.incloud.aop.annotation.OptLog;
import com.inspur.incloud.aop.optlog.IOptLogService;
import com.inspur.incloud.common.UserSession;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

import javax.servlet.http.HttpServletRequest;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.List;

/**
 * @description: 记录错误日志，统一处理异常
 * @author: lidongyue
 * @since 2019-01-14
 **/
@Aspect
@Component
@Slf4j
public class AopController2 {

    @Autowired
    private IOptLogService optLogService;

    /**
     * controller切面，录操作日志
     *
     * @param joinPoint
     * @return
     */
    @Around("execution(com.inspur.incloud.common.OperationResult com.inspur.incloud.icompute.*.controller..*.*(..))" +
            " && (@annotation(com.inspur.incloud.aop.annotation.OptLog))")
    public Object aroundOptControllerAdvice(ProceedingJoinPoint joinPoint) {
        Object returnObject = null;
        String language;
        UserSession userSession = null;
        try {
            // 1.获取userSession
            HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();
            language = request.getHeader("X-Accept-Language");
            userSession = (UserSession) request.getAttribute("userSession");

            // 2.打印入参
            Class<?> clazz = joinPoint.getTarget().getClass();
            String className = clazz.getName();

            Method method = ((MethodSignature) joinPoint.getSignature()).getMethod();
            String methodName = method.getName();

            String args = JSONObject.toJSONString(joinPoint.getArgs());

            log.info(className + "." + methodName + " invoke begin, param = " + args);


            // 3.打印执行时间和返回结果
            long startTime = System.currentTimeMillis();

            returnObject = joinPoint.proceed();

            Long executeTime = System.currentTimeMillis() - startTime;

            log.info(className + "." + methodName + " invoke end. executeTime=" + executeTime + ", return result=" + JSONObject.toJSONString(returnObject));

            // 4.记录操作日志
            OptLog optLog = clazz.getAnnotation(OptLog.class);
            if (optLog.isSyn()) {
                String idVal = getIdVal(clazz);
                List<String> nameListVal = getNameListVal(clazz);
                optLogService.successOpt(optLog, userSession, nameListVal, idVal);
            }
        } catch (Throwable e) {
            log.error(e.getMessage(), e);
            
            Class<?> clazz = joinPoint.getTarget().getClass();
            OptLog optLog = clazz.getAnnotation(OptLog.class);

            String idVal = getIdVal(clazz);
            List<String> nameListVal = getNameListVal(clazz);
            
            optLogService.failExpOpt(e, optLog, nameListVal, idVal, userSession, joinPoint.getArgs());
        } finally {
            // 释放ThreadLocal空间
            Class<?> clazz = joinPoint.getTarget().getClass();

            ThreadLocal<String> idValTl = getIdValTl(clazz);
            if (idValTl != null) {
                idValTl.remove();
            }

            ThreadLocal<List<String>> nameListValTl = getNameListValTl(clazz);
            if (nameListValTl != null) {
                nameListValTl.remove();
            }
        }
        return returnObject;
    }

    /**
     * 查询ThreadLocal类型idVal
     * @param clazz
     * @return ThreadLocal<String>
     */
    private ThreadLocal<String> getIdValTl(Class<?> clazz) {
        try {
            Field field = clazz.getSuperclass().getDeclaredField("idVal");
            field.setAccessible(true);

            Object baseController = Class.forName(clazz.getName());

            return (ThreadLocal<String>) field.get(baseController);
        } catch (Exception e) {
            log.error(e.getMessage(), e);
        }
        return null;
    }

    /**
     * 查询String类型idVal
     * @param clazz
     * @return String
     */
    private String getIdVal(Class<?> clazz) {
        try {
            ThreadLocal<String> threadLocal = getIdValTl(clazz);
            return (threadLocal != null ? threadLocal.get() : null);
        } catch (Exception e) {
            log.error(e.getMessage(), e);
        }
        return null;
    }

    /**
     * 查询ThreadLocal<List<String>>类型nameListVal
     * @param clazz
     * @return ThreadLocal<List<String>>
     */
    private ThreadLocal<List<String>> getNameListValTl(Class<?> clazz) {
        try {
            Field field = clazz.getSuperclass().getDeclaredField("nameListVal");
            field.setAccessible(true);

            Object baseController = Class.forName(clazz.getName());

            return (ThreadLocal<List<String>>) field.get(baseController);
        } catch (Exception e) {
            log.error(e.getMessage(), e);
        }
        return null;
    }

    /**
     * 查询List<String>类型nameListVal
     * @param clazz
     * @return List<String>
     */
    private List<String> getNameListVal(Class<?> clazz) {
        try {
            ThreadLocal<List<String>> threadLocal = getNameListValTl(clazz);
            return (threadLocal != null ? threadLocal.get() : null);
        } catch (Exception e) {
            log.error(e.getMessage(), e);
        }
        return null;
    }
}
```

最后统一异常处理，在上述代码的基础上，对catch细分处理即可，就不再写示例了。













































