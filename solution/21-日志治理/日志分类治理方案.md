基于对inetwork、icompute的日志治理经验，控制台输出日志过多，主要原因有以下几点：

1. icos ruquest id 在不停的打印。
2. 依赖其他的模块，不停打印与本模块无关的日志。
3. 同一个错误堆栈，在不同的位置重复多次打印。
4. 有些很明确的错误，只需要打印e.getMessage()一行错误信息即可，不需要打印完整错误堆栈。

基于以上原因分析，采用如下方案对两个模块的日志进行治理。

# 一、日志分类存储

## 1.1. 日志分类

1. 控制台日志
2. 全量日志
3. icos request id 日志
4. 与本模块无关日志
5. others


## 1.2. 日志分类存储配置示例

1. 控制台日志

   ```xml
   <appender name="console" class="ch.qos.logback.core.ConsoleAppender">
       <!-- filter中定义的logger，日志不输出到控制台 -->
       <filter class="com.inspur.incloud.icompute.openstack.config.LogBackFilter"/>
       <encoder>
           <pattern>%d %p (%file:%line\)- %m%n</pattern>
           <!-- 控制台也要使用UTF-8，不要使用GBK，否则会中文乱码 -->
           <charset>UTF-8</charset>
       </encoder>
   </appender>
   ```

   LogBackFilter：用于定义哪些日志不输出到控制台

   ```java
   public class LogBackFilter extends Filter<ILoggingEvent> {
   
       // icos requestId相关日志
       private static final String [] REQUEST_LOGGER_NAMES = new String[] {
               "com.inspur.incloud.openstacksdk.connection.OpenstackRestClient"
       };
   
       // 与本模块无关日志logger
       private static final String [] CARELESS_LOGGER_NAMES = new String[] {
               "com.inspur.incloud.itask.asyntask.chain.impl.ChainTaskMonitorHelper",
               "springfox.documentation.swagger.readers.operation.OperationImplicitParameterReader",
               "com.inspur.incloud.itask.conf.XxlJobConfig",
               "org.openstack4j.connectors.httpclient.HttpResponseImpl"
       };
   
       @Override
       public FilterReply decide(ILoggingEvent iLoggingEvent) {
           final ArrayList<String> loggerNameList = new ArrayList<>();
           loggerNameList.addAll(Arrays.asList(REQUEST_LOGGER_NAMES));
           loggerNameList.addAll(Arrays.asList(CARELESS_LOGGER_NAMES));
   
           for (String loggerName : loggerNameList) {
               if (iLoggingEvent.getLoggerName().contains(loggerName)) {
                   return FilterReply.DENY;
               }
           }
   
           return FilterReply.ACCEPT;
       }
   }
   ```

2. 全量日志

   ```xml
   <appender name="full" class="ch.qos.logback.core.rolling.RollingFileAppender">
       <File>${LOG_PATH}/${LOG_FILE}</File>
       <encoder>
           <pattern>%d %p (%file:%line\)- %m%n</pattern>
           <charset>UTF-8</charset>
       </encoder>
       <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
           <!-- 添加.gz 历史日志会启用压缩 大大缩小日志文件所占空间 -->
           <fileNamePattern>${LOG_PATH}/daily/${LOG_FILE}.%d{yyyy-MM-dd}.gz
           </fileNamePattern>
           <maxHistory>30</maxHistory><!-- 保留30天日志 -->
       </rollingPolicy>
   </appender>
   ```

3. requestId相关日志

   ```xml
   <appender name="icos-request-id" class="ch.qos.logback.core.rolling.RollingFileAppender">
       <File>${LOG_PATH}/icos-request-id.log</File>
       <encoder>
           <pattern>%d %p (%file:%line\)- %m%n</pattern>
           <charset>UTF-8</charset>
       </encoder>
       <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
           <fileNamePattern>${LOG_PATH}/daily/icos-request-id.log.%d{yyyy-MM-dd}.gz</fileNamePattern>
           <maxHistory>30</maxHistory>
       </rollingPolicy>
   </appender>
   <logger name="com.inspur.incloud.openstacksdk.connection.OpenstackRestClient" level="INFO">
       <appender-ref ref="icos-request-id" />
   </logger>
   ```

4. 与本模块无关日志

   ```xml
   <appender name="careless" class="ch.qos.logback.core.rolling.RollingFileAppender">
       <File>${LOG_PATH}/careless.log</File>
       <encoder>
           <pattern>%d %p (%file:%line\)- %m%n</pattern>
           <charset>UTF-8</charset>
       </encoder>
       <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
           <fileNamePattern>${LOG_PATH}/daily/careless.log.%d{yyyy-MM-dd}.gz</fileNamePattern>
           <maxHistory>30</maxHistory>
       </rollingPolicy>
   </appender>
   <logger name="com.inspur.incloud.itask.asyntask.chain.impl.ChainTaskMonitorHelper" level="INFO">
       <appender-ref ref="careless" />
   </logger>
   <logger name="springfox.documentation.swagger.readers.operation.OperationImplicitParameterReader" level="INFO">
       <appender-ref ref="careless" />
   </logger>
   <logger name="com.inspur.incloud.itask.conf.XxlJobConfig" level="INFO">
       <appender-ref ref="careless" />
   </logger>
   <logger name="org.openstack4j.connectors.httpclient.HttpResponseImpl" level="INFO">
       <appender-ref ref="careless" />
   </logger>
   ```

# 二、处理不合理打印日志

## 2.1. 部分异常只需打印e.getMessage()

例如，不存在此资源异常，如浮动IP不存在、安全组不存在。通过错误码即可获取足够的信息，不需要打印完整的错误堆栈。以inetwork为例，该问题可在通用异常处理器中统一处理，示例代码如下：

```java
@Slf4j
@ControllerAdvice
@ResponseBody
public class ControllerExceptionHandler {
	// 这些错误不打印详细日志
    final static List<String> exceptErrList = Arrays.asList("INETWORK_FLOATINGIP_NOT_EXIST"
            , "INETWORK_SECURITY_GROUP_NOT_EXIST", "INETWORK_VPC_NOT_EXIST", "INETWORK_NET_NOT_EXIST");

 	@ExceptionHandler(CloudBusinessException.class)
    public OperationResult<Object> handlerCloudBusinessException(CloudBusinessException e, HttpServletRequest request) {
        // 1.打印错误日志
        log.error("uri ={}", request.getRequestURI());
        if (exceptErrList.contains(e.getMsgCode())) {
            log.error(e.getMessage());
        } else {
            log.error(e.getMessage(), e);
        }

        // 2.记录操作日志
        operLogUtils.writeOperLog(false, e);

        // 3.return
        return OperationResult.fail(e.getMsgCode(), e.getParamList());
    }
   
}
```

## 2.2. 部分异常不需要重复多次打印

例如，连接openstack资源池时，如果连接出错，会在不同位置重复打印四次日志。去除其中的三个，只保留一个在业务调用处的日志打印即可。

并且结合2.1章节，这些日志用有些只需要打印e.getMessage()，比如401问题、超时问题，这样可以进一步减少日志在控制台上的输出，以及在全量日志中的存储。

```java
public class OpenstackConnPool {
    public static Object execute(Callable task, Long outTime, boolean needResponse) throws RuntimeException {
        try {
           ...
        } catch (Exception e) {
            if (e.toString().contains("timed out")) {
                log.error(StringUtils.substring(e.toString(), 0, 100));
            } else {
                log.error(e.getMessage(), e);
            }
            throw new RuntimeException(e);
        }
        return null;
    }
}
```

```java
public static OSClientObj connectCenter(OpenstackCenterConnectionInfo center, String projectId) throws Exception {
        log.info("------ start connect openstack ceneter: " + center.getIp() + ", projectMor: " + projectId + " ------");
            OSClientV3 clientV3 = (OSClientV3) OpenstackConnPool.execute(new OSClientThreadExtended(null, parameters) {
                @Override
                public OSClientV3 innerCall(OSClientV3 os, Object[] parameters) throws Exception {
                    OSClientV3 osclientv3 = null;
                    try { 
                        ...
                    } catch (RegionEndpointNotFoundException e) {
                        log.error(e.toString(), e);
                        throw e;
                    } catch (Exception e) {
                        if (e.toString().contains("timed out")) {
                            log.error(StringUtils.substring(e.toString(), 0, 100));
                        } else {
                            log.error(e.toString(), e);
                        }
                        throw e;
                    }
                    return osclientv3;
                }

            }, OpenstackConstant.THREAD_DEFAULT_WAIT_TIME);
            ...
        } catch (Exception e) {
            if (e.toString().contains("timed out")) {
                log.error(StringUtils.substring(e.toString(), 0, 100));
            } else {
                log.error(e.toString(), e);
            }
            throw e;
        }
        return osclientobj;
    }
```

这三个地方，先改成只打印 e.getMessage()，后面确认完全没用再全部移除。

日志治理是一个持续的过程，需要持续的发现问题，解决问题。





阿里代码规约，日志：

1. 【强制】应用中不可直接使用日志系统(Log4j、Logback)中的 API，而应依赖使用日志框架 SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。

   ```
    import org.slf4j.Logger;
    import org.slf4j.LoggerFactory;
    private static final Logger logger = LoggerFactory.getLogger(Abc.class);
   ```

2. 【强制】日志文件推荐至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。

3. 【强制】应用中的扩展日志(如打点、临时监控、访问日志等)命名方式: appName_logType_logName.log。logType:日志类型，推荐分类有 stats/desc/monitor/visit 等；logName:日志描述。这种命名的好处: 通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。
   **正例** : mppserver 应用中单独监控时区转换异常，如: mppserver_monitor_timeZoneConvert.log
   **说明** : 推荐对日志进行分类，如将错误日志和业务日志分开存放，便于开发人员查看，也便于 通过日志对系统进行及时监控。

4. 【强制】对 trace/debug/info 级别的日志输出，必须使用条件输出形式或者使用占位符的方 式。
   **说明** : logger.debug("Processing trade with id: " + id + " symbol: " + symbol);如果日志级别是 warn，上述日志不会打印，但是会执行字符串拼接操作，如果 symbol 是对象，会执行 toString() 方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。
   **正例** : (条件)

   ```
    if (logger.isDebugEnabled()) {
        logger.debug("Processing trade with id: " + id + " symbol: " + symbol);
    }
   ```

   **正例** : (占位符)

   ```
    logger.debug("Processing trade with id: {} symbol : {} ", id, symbol);
   ```

5. 【强制】避免重复打印日志，浪费磁盘空间，务必在 log4j.xml 中设置 additivity=false。
   **正例** : `<logger name="com.taobao.dubbo.config" additivity="false">`

6. 【强制】异常信息应该包括两类信息: 案发现场信息和异常堆栈信息。如果不处理，那么通过关键字 throws 往上抛出。
   **正例** : logger.error(各类参数或者对象 toString + "_" + e.getMessage(), e);

7. 【推荐】谨慎地记录日志。生产环境禁止输出 debug 日志；有选择地输出 info 日志；如果使用 warn 来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘 撑爆，并记得及时删除这些观察日志。
   **说明** : 大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。记录日志时请思考: 这些日志真的有人看吗? 看到这条日志你能做什么? 能不能给问题排查带来好处?

8. 【参考】可以使用 warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。注意日志输出的级别，error 级别只记录系统逻辑出错、异常等重要的错误信息。如非必要，请不要在此场景打出 error 级别。

