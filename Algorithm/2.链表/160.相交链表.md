这个题我想到了两种解法：

1. 是暴力解法，双层循环，链表A每循环个元素，循环一遍链表B，直到找到相交节点。
2. 既然题目给出的条件是，从相交节点后的节点都是相同的，那么如果我们可以从链表尾部开始，反向比较，直到匹配到不相同节点为止，会更简单。但是这里有个问题，题目给的是单向链表，只能从头往尾走，无法反向。那么进一步的，我又想到，可以先弄清楚两个链表的长度，然后长度较长的链表开始移动，直到这个点后的节点数，和长度较短的链表长度相同为止。而这个思路，同样起源于，相交节点后的全部节点都相同。

第一种算法就不写代码了，十分常见。下面是第二种算法的代码实现：

 ```java
 /**
  * Definition for singly-linked list.
  * public class ListNode {
  *     int val;
  *     ListNode next;
  *     ListNode(int x) {
  *         val = x;
  *         next = null;
  *     }
  * }
  */
 public class Solution {
     public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
         if (headA == null || headB == null) return null;
         
         int la = 0;
         ListNode curA = headA;
         while (curA != null) {
             curA = curA.next;
             la++;
         }
         
         int lb = 0;
         ListNode curB = headB;
         while (curB != null) {
             curB = curB.next;
             lb++;
         }
 
         curA = headA;
         curB = headB;
 
         if (la >= lb) {
             for (int i = 0; i < la - lb; i++) {
                 curA = curA.next;
             }
         } else {
             for (int i = 0; i < lb - la; i++) {
                 curB = curB.next;
             }
         }
 
         while (curA != null) {
             if (curA == curB) return curA;
             curA = curA.next;
             curB = curB.next;
         }
 
         return null;
     }
 }
 ```



第三种算法，利用双指针，时间复杂度同方法二，代码如下：

 ```java
 /**
  * Definition for singly-linked list.
  * public class ListNode {
  *     int val;
  *     ListNode next;
  *     ListNode(int x) {
  *         val = x;
  *         next = null;
  *     }
  * }
  */
 public class Solution {
     public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
         if (headA == null || headB == null) return null;
         
         ListNode curA = headA, curB = headB;
         while (curA != curB) {
             curA = (curA == null ? headB : curA.next);
             curB = (curB == null ? headA : curB.next);
         }
 
         return curA;
     }
 }
 ```

